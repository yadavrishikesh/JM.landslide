devtools::document()
devtools::document()
dir.create("data")
devtools::document()
devtools::build()
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
detach("package:JM.landslide", unload = TRUE)
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(JM.landslide)
library(JM.landslide)
getwd()
devtools::document()
devtools::build()
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
detach("package:JM.landslide", unload = TRUE)
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
getwd()
ls
devtools::document()
devtools::build()
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
detach("package:JM.landslide", unload = TRUE)
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
detach("package:JM.landslide", unload = TRUE)
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
getwd()
devtools::document()
devtools::build()
detach("package:JM.landslide", unload = TRUE)
install.packages("C:/Users/11322929/KAUST Dropbox/Rishikesh Yadav/BookChapter_EVA/JM.landslide_0.0.0.9000.tar.gz", repos = NULL, type = "source")
getwd()
devtools::document()
getwd()
rm(list = ls())
setwd(this.path::here())
library(JM.landslide)
data("Wenchuan_info_used_for_simulation") ## data that contains some information of Wenchuan landslides data
library(spdep)
library(INLA)
nb2INLA("adjgraph-sim.txt", poly2nb(shp_selected, queen=F, row.names=shp_selected$SU_ID))
adjacensy<- inla.read.graph(filename = "adjgraph-sim.txt")
#### creating the precision matrix
N<-adjacensy$n
diag.Q<- diag(adjacensy$nnbs, N)
A.Q<-matrix(0, nrow = N, ncol = N)
for (i in 1:N) {
A.Q[i,adjacensy$nbs[[i]]]<-1
}
Q<- diag.Q-A.Q ### Precision matrix
dim(Q)
rankMatrix(Q)
### Fixed parameters
kappa_w1<- 10 # precision parameter in iCAR prior W1
kappa_w2<- 5  #precision parameter in iCAR prior W2
kappa_eta<- 10 #precision parameter in independent random effects \varepsilon_{\eta}
kappa_mu<- 5 #precision parameter in independent random effects \varepsilon_{\mu}
intercept1<- 2 ## intercept for counts
intercept2<- 4 ## intercept for sizes
beta<- 1 ## shared parameter between the count and size processes
other.hyper<- list(kappa_w1 = kappa_w1,
kappa_w2  =kappa_w2,
kappa_eta =kappa_eta,
kappa_mu= kappa_mu,
intercept1=intercept1,
intercept2= intercept2,
beta = beta) ### collecting all the parameteres into a vectors
### simulate some covariates for demonstrations #########
Z1<- mvtnorm::rmvnorm(dim(Q)[1], mean = rep(0,3))
Z2<- mvtnorm::rmvnorm(dim(Q)[1], mean = rep(0,2))
hyper.mu<- c(20, 0.1)
p<- ncol(Z1)
q<- ncol(Z2)
set.seed(1);beta1<- runif(p,-1,1)  ## fixed covariates coefficient for counts
set.seed(1); beta2<- runif(q,-1,1) ## fixed covariates coefficient for sizes
model_type<- "FE"
?JM.landslide::sim_mark_function
rm(list = ls())
setwd(this.path::here())
library(JM.landslide)
data("Wenchuan_info_used_for_simulation") ## data that contains some information of Wenchuan landslides data
library(spdep)
library(INLA)
nb2INLA("adjgraph-sim.txt", poly2nb(shp_selected, queen=F, row.names=shp_selected$SU_ID))
adjacensy<- inla.read.graph(filename = "adjgraph-sim.txt")
#### creating the precision matrix
N<-adjacensy$n
diag.Q<- diag(adjacensy$nnbs, N)
A.Q<-matrix(0, nrow = N, ncol = N)
for (i in 1:N) {
A.Q[i,adjacensy$nbs[[i]]]<-1
}
Q<- diag.Q-A.Q ### Precision matrix
dim(Q)
rankMatrix(Q)
### Fixed parameters
kappa_w1<- 10 # precision parameter in iCAR prior W1
kappa_w2<- 5  #precision parameter in iCAR prior W2
kappa_eta<- 10 #precision parameter in independent random effects \varepsilon_{\eta}
kappa_mu<- 5 #precision parameter in independent random effects \varepsilon_{\mu}
intercept1<- 2 ## intercept for counts
intercept2<- 4 ## intercept for sizes
beta<- 1 ## shared parameter between the count and size processes
other.hyper<- list(kappa_w1 = kappa_w1,
kappa_w2  =kappa_w2,
kappa_eta =kappa_eta,
kappa_mu= kappa_mu,
intercept1=intercept1,
intercept2= intercept2,
beta = beta) ### collecting all the parameteres into a vectors
### simulate some covariates for demonstrations #########
Z1<- mvtnorm::rmvnorm(dim(Q)[1], mean = rep(0,3))
Z2<- mvtnorm::rmvnorm(dim(Q)[1], mean = rep(0,2))
hyper.mu<- c(20, 0.1)
p<- ncol(Z1)
q<- ncol(Z2)
set.seed(1);beta1<- runif(p,-1,1)  ## fixed covariates coefficient for counts
set.seed(1); beta2<- runif(q,-1,1) ## fixed covariates coefficient for sizes
model_type<- "FE"
?JM.landslide::sim_mark_function
set.seed(1)
Sim_mark_data<-  sim_mark_function(Q=Q,
hyper.mu = hyper.mu,
other.hyper=other.hyper,
beta1=beta1, beta2=beta2,
Z1=as.matrix(Z1), Z2=as.matrix(Z2),
mark_dist="eGPD",
model_type = "model_type"
)
Y<-Sim_mark_data$Y  ## the simulated counts
A<-Sim_mark_data$A  ## the simulated sizes
max(A)
mu<- Sim_mark_data$mu
eta<- Sim_mark_data$eta
W1<- Sim_mark_data$W1
W2<- Sim_mark_data$W2
par(mfrow=c(2,2))
hist(Y);hist(A);hist(mu);hist(eta)
#### saving the true values to compare it with the posterior predictive distributions
true.values<- c(exp(log.hyper.mu),
if(model_type=="FE"){as.numeric(unlist(other.hyper))[c(3:6)]} else{as.numeric(unlist(other.hyper))},
beta1,
beta2,
Sim_mark_data$eta[1:2],
if(model_type=="jSp"){
Sim_mark_data$W1[1]
},
Sim_mark_data$mu[1],
if(model_type=="jSp"){
Sim_mark_data$W2[1]
}
)
#### create A excatly zeros where we have zeros in Y
A[Y==0]<- 0
sum(Y==0)
save(Y,
A,
other.hyper,
Sim_mark_data,
Z1,
Z2,
adjacensy,
coords,
true.values,
file=paste0("SimulatedData_", model_type,".RData")
)
#### saving the true values to compare it with the posterior predictive distributions
true.values<- c(exp(log.hyper.mu),
if(model_type=="FE"){as.numeric(unlist(other.hyper))[c(3:6)]} else{as.numeric(unlist(other.hyper))},
beta1,
beta2,
Sim_mark_data$eta[1:2],
if(model_type=="jSp"){
Sim_mark_data$W1[1]
},
Sim_mark_data$mu[1],
if(model_type=="jSp"){
Sim_mark_data$W2[1]
}
)
#### saving the true values to compare it with the posterior predictive distributions
true.values<- c(hyper.mu,
if(model_type=="FE"){as.numeric(unlist(other.hyper))[c(3:6)]} else{as.numeric(unlist(other.hyper))},
beta1,
beta2,
Sim_mark_data$eta[1:2],
if(model_type=="jSp"){
Sim_mark_data$W1[1]
},
Sim_mark_data$mu[1],
if(model_type=="jSp"){
Sim_mark_data$W2[1]
}
)
#### create A excatly zeros where we have zeros in Y
A[Y==0]<- 0
sum(Y==0)
save(Y,
A,
other.hyper,
Sim_mark_data,
Z1,
Z2,
adjacensy,
coords,
true.values,
file=paste0("SimulatedData_", model_type,".RData")
)
model_type<- "jSp"
?JM.landslide::sim_mark_function
set.seed(1)
Sim_mark_data<-  sim_mark_function(Q=Q,
hyper.mu = hyper.mu,
other.hyper=other.hyper,
beta1=beta1, beta2=beta2,
Z1=as.matrix(Z1), Z2=as.matrix(Z2),
mark_dist="eGPD",
model_type = model_type
)
Y<-Sim_mark_data$Y  ## the simulated counts
A<-Sim_mark_data$A  ## the simulated sizes
max(A)
mu<- Sim_mark_data$mu
eta<- Sim_mark_data$eta
W1<- Sim_mark_data$W1
W2<- Sim_mark_data$W2
par(mfrow=c(2,2))
hist(Y);hist(A);hist(mu);hist(eta)
#### saving the true values to compare it with the posterior predictive distributions
true.values<- c(hyper.mu,
if(model_type=="FE"){as.numeric(unlist(other.hyper))[c(3:6)]} else{as.numeric(unlist(other.hyper))},
beta1,
beta2,
Sim_mark_data$eta[1:2],
if(model_type=="jSp"){
Sim_mark_data$W1[1]
},
Sim_mark_data$mu[1],
if(model_type=="jSp"){
Sim_mark_data$W2[1]
}
)
#### create A excatly zeros where we have zeros in Y
A[Y==0]<- 0
sum(Y==0)
save(Y,
A,
other.hyper,
Sim_mark_data,
Z1,
Z2,
adjacensy,
coords,
true.values,
file=paste0("SimulatedData_", model_type,".RData")
)
?JM.landslide::sim_mark_function
rm(list = ls())
setwd(this.path::here())
library(JM.landslide)
data("Wenchuan_info_used_for_simulation") ## data that contains some information of Wenchuan landslides data
?JM.landslide::sim_mark_function
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
set.seed(123)
outputs<- mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = "WS",
mark_dist = "bGPD",
thr.family ="gamma",
model_type =  "jSp",
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
print.result = TRUE,
traceplot = TRUE,
samples.store = 100
)
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
set.seed(123)
outputs<- mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = "WS",
mark_dist = "eGPD",
thr.family ="gamma",
model_type =  "jSp",
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 2e3,
print.result = TRUE,
traceplot = TRUE,
samples.store = 1000
)
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
set.seed(123)
outputs<- mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = "WS",
mark_dist = "eGPD",
thr.family ="gamma",
model_type =  "jSp",
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 2e3,
print.result = TRUE,
traceplot = TRUE,
samples.store = 100
)
