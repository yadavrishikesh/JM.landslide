rm(list = ls())
model_combinations
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model_combinations
model.no<- 1
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 1
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 1000,
fit_thr_model_only = FALSE,
samples.store = 100
)
outputs$JM.info$summry_hyper
outputs$JM.info$summ_fixed_effects
outputs$JM.info$est_probs
outputs$JM.info$est_probs$cond
outputs$JM.info$est_probs$cond[,6]
outputs$JM.info$est_probs$cond$mean[,6]
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 1
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
model_combinations
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 9
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
outputs$JM.info$summry_hyper
devtools::document()
devtools::install()
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model_combinations
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 2
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 2
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
devtools::document()
devtools::install()
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 2
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
model_combinations
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 4
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
outputs$JM.info$est_counts_and_sizes$OOS$post.mean.Y
outputs$JM.info$est_counts_and_sizes$OOS$post.sd.Y
outputs$JM.info$est_counts_and_sizes$OOS$post.mean.A
outputs$JM.info$est_counts_and_sizes$OOS$post.mean.A
rm(list = ls())
setwd(this.path::here())
load("Wenchuan_data.RData")
?JM.landslide::mcmc_sampler
CV <- c("WS", "OOS")
model_type <- c("FE", "jSp")
mark_dist <- c("eGPD", "bGPD", "tgGPD")
include_pga<- c(TRUE, FALSE)
model_combinations <- as.matrix(expand.grid(CV = CV, model_type = model_type, mark_dist = mark_dist, include_pga=include_pga))
model_combinations<- data.frame(CV=model_combinations[,1],
model_type = model_combinations[,2],
mark_dist = model_combinations[,3],
include_pga = model_combinations[,4])
model.no<- 2
if(model_combinations[model.no,4]==FALSE){
Z1<- Z1[,-c(9, 10)]
Z2<- Z1
} else {
Z1<- Z1
Z2<- Z1
}
set.seed(123)
outputs<- JM.landslide::mcmc_sampler(Y = Y,
A = sqrt(A),
Z1 = Z1,
Z2 = Z2,
CV = model_combinations$CV[model.no],
mark_dist = model_combinations$mark_dist[model.no],
model_type =  model_combinations$model_type[model.no],
adjacensy =  adjacensy,
q.probs = as.numeric(quantile(sqrt(A), probs = seq(0.50,0.99,0.05))),
q.probs.thr = 0.83, #seq(0.80, 0.98, by=0.01),
no.rm.obs = 2000,
N.MCMC = 500,
fit_thr_model_only = FALSE,
samples.store = 50
)
devtools::document()
devtools::install()
library(JM.landslide)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(JM.landslide)
# Define the model type
model_type <- "jSp"
# Load the simulated data
load(paste0("SimulatedData_", model_type, ".RData"))
Sim_mark_data$Y
# Access results
Y <- Sim_mark_data$Y
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(JM.landslide)
# Load necessary libraries
library(JM.landslide)
library(spdep)
library(INLA)
# Load Wenchuan landslides data
data("Wenchuan_info_used_for_simulation")
# Create adjacency graph file
nb2INLA("adjgraph-sim.txt", poly2nb(shp_selected, queen = FALSE, row.names = shp_selected$SU_ID))
adjacensy <- inla.read.graph(filename = "adjgraph-sim.txt")
# Create the precision matrix
N <- adjacensy$n
diag.Q <- diag(adjacensy$nnbs, N)
A.Q <- matrix(0, nrow = N, ncol = N)
for (i in 1:N) {
A.Q[i, adjacensy$nbs[[i]]] <- 1
}
Q <- diag.Q - A.Q  # Precision matrix
Q
dim(Q)
# Set fixed parameters
kappa_w1 <- 10
kappa_w2 <- 5
kappa_eta <- 10
kappa_mu <- 5
intercept1 <- 2
intercept2 <- 4
beta <- 1
other.hyper <- list(
kappa_w1 = kappa_w1,
kappa_w2 = kappa_w2,
kappa_eta = kappa_eta,
kappa_mu = kappa_mu,
intercept1 = intercept1,
intercept2 = intercept2,
beta = beta
)
# Simulate covariates
Z1 <- mvtnorm::rmvnorm(N, mean = rep(0, 3))
Z2 <- mvtnorm::rmvnorm(N, mean = rep(0, 2))
hyper.mu<- c(20,0.1)
set.seed(1)
beta1 <- runif(ncol(Z1), -1, 1)
beta2 <- runif(ncol(Z2), -1, 1)
model_type <- "FE"  # Fixed Effects
# Simulate data using the function
set.seed(1)
Sim_mark_data <- sim_mark_function(
Q = Q,
hyper.mu =  hyper.mu,
other.hyper = other.hyper,
beta1 = beta1, beta2 = beta2,
Z1 = as.matrix(Z1), Z2 = as.matrix(Z2),
mark_dist = "eGPD",
model_type = model_type
)
Sim_mark_data$Y
# Access results
Y <- Sim_mark_data$Y
A <- Sim_mark_data$A
mu <- Sim_mark_data$mu
eta <- Sim_mark_data$eta
W1 <- Sim_mark_data$W1
W2 <- Sim_mark_data$W2
par(mfrow=c(3,2))
hist(Y)
hist(A)
hist(eta)
hist(mu)
hist(W1)
hist(W2)
W1
model_type <- "jSp"  # Fixed Effects
# Simulate data using the function
set.seed(1)
Sim_mark_data <- sim_mark_function(
Q = Q,
hyper.mu =  hyper.mu,
other.hyper = other.hyper,
beta1 = beta1, beta2 = beta2,
Z1 = as.matrix(Z1), Z2 = as.matrix(Z2),
mark_dist = "eGPD",
model_type = model_type
)
# Access results
Y <- Sim_mark_data$Y
A <- Sim_mark_data$A
mu <- Sim_mark_data$mu
eta <- Sim_mark_data$eta
W1 <- Sim_mark_data$W1
W2 <- Sim_mark_data$W2
par(mfrow=c(3,2))
hist(Y)
hist(A)
hist(eta)
hist(mu)
hist(W1)
hist(W2)
# Define the model type
model_type <- "jSp"
# Load the simulated data
load(paste0("SimulatedData_", model_type, ".RData"))
# Define the model type
model_type <- "jSp"
# Fit the model using the MCMC sampler
outputs <- mcmc_sampler(
Y = Sim_mark_data$Y,               # Simulated landslide counts
A = Sim_mark_data$A,               # Simulated landslide sizes
Z1 = Z1,             # Covariates for counts
Z2 = Z2,             # Covariates for sizes
CV = "WS",          # Type of cross-validation (within sample)
mark_dist = "eGPD", # Distribution of the mark process
thr.family = "gamma", # Family of the threshold model
model_type = model_type, # Model type used in the simulation
adjacensy = adjacensy, # Adjacency structure for the spatial model
no.rm.obs = 200,
N.MCMC = 5000,
samples.store = 500
)
# Define the model type
model_type <- "jSp"
outputs <- mcmc_sampler(
Y = Sim_mark_data$Y,               # Simulated landslide counts
A = Sim_mark_data$A,               # Simulated landslide sizes
Z1 = Z1,             # Covariates for counts
Z2 = Z2,             # Covariates for sizes
CV = "WS",          # Type of cross-validation (within sample)
mark_dist = "eGPD", # Distribution of the mark process
thr.family = "gamma", # Family of the threshold model
model_type = model_type, # Model type used in the simulation
adjacensy = adjacensy, # Adjacency structure for the spatial model
no.rm.obs = 200,
N.MCMC = 2000,
samples.store = 250,
print.result = FALSE
)
outputs$JM.info$summry_hyper$hyper_size_dist
outputs$JM.info$summry_hyper
outputs$JM.info$summ_fixed_effects
getwd()
devtools::build_vignettes()
devtools::check()
devtools::check()
devtools::check()
devtools::build_vignettes()
devtools::check()
devtools::document()
devtools::install()
library(spam)
getwd()
devtools::clean_vignettes()
