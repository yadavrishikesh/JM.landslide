% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler_joint-model-jSp.R
\name{mcmc_sampler_joint_model_jSp}
\alias{mcmc_sampler_joint_model_jSp}
\title{MCMC Sampler for Joint Spatial Model}
\usage{
mcmc_sampler_joint_model_jSp(
  N.MCMC,
  Y,
  ind_NA_Y,
  A,
  ind_NA_A,
  Z1,
  Z2,
  model_type,
  Sim_data,
  thin,
  adapt,
  burn_in1,
  burn_in2,
  tun.eta,
  tun.mu,
  tun.hyper.mu,
  tun.hyper.GP,
  mark_dist,
  hyper_fixed,
  print.result = TRUE,
  traceplot = FALSE,
  model.base,
  CV,
  true.values = NULL,
  simulation,
  nbd_info,
  no_of_nbd,
  node.set,
  ind_zeros_counts,
  threshold,
  thr.acces.ind,
  thr.prob,
  q.probs,
  hyper.mu_adapt_seq2,
  mu_adapt_seq2,
  eta_adapt_seq2,
  samples.store,
  init.seed
)
}
\arguments{
\item{N.MCMC}{Integer. Number of MCMC iterations.}

\item{Y}{Numeric vector. Count data of length \code{n1}.}

\item{ind_NA_Y}{Logical vector. Indicator for missing values in \code{Y}.}

\item{A}{Numeric vector. Size data of length \code{n2}.}

\item{ind_NA_A}{Logical vector. Indicator for missing values in \code{A}.}

\item{Z1}{Matrix. Covariates for the count data (dimensions \verb{n1 x p}).}

\item{Z2}{Matrix. Covariates for the size data (dimensions \verb{n2 x q}).}

\item{model_type}{Character. Type of model to fit (e.g., joint spatial model).}

\item{Sim_data}{Logical. If \code{TRUE}, simulation data is used for testing.}

\item{thin}{Integer. Thinning interval for MCMC sampling.}

\item{adapt}{Integer. Adaptation interval for tuning parameter updates.}

\item{burn_in1}{Integer. First burn-in period for MCMC sampling.}

\item{burn_in2}{Integer. Second burn-in period for MCMC sampling.}

\item{tun.eta}{Numeric. Tuning parameter for MH steps related to \code{eta}.}

\item{tun.mu}{Numeric. Tuning parameter for MH steps related to \code{mu}.}

\item{tun.hyper.mu}{Numeric. Tuning parameter for MH steps related to the hyperparameters of the mark distribution.}

\item{tun.hyper.GP}{Numeric. Tuning parameter for MH steps related to the hyperparameters of the Generalized Pareto distribution (GP).}

\item{mark_dist}{Character. Type of distribution used for \code{A} (e.g., \code{"eGPD"}, \code{"bGPD"}, \code{"tgGPD"}).}

\item{hyper_fixed}{List. Fixed hyperparameters for the model.}

\item{print.result}{Logical. If \code{TRUE}, prints progress and acceptance rates during MCMC.}

\item{traceplot}{Logical. If \code{TRUE}, generates traceplots for parameter diagnostics.}

\item{model.base}{Logical. If \code{TRUE}, models count and size data independently.}

\item{CV}{Character. Cross-validation type: \code{"WS"} for within-sample or \code{"OOS"} for out-of-sample.}

\item{true.values}{Numeric vector. True parameter values for validating simulation experiments.}

\item{simulation}{Logical. If \code{TRUE}, runs the function as a simulation experiment.}

\item{nbd_info}{Matrix. Information on the adjacency structure of spatial units.}

\item{no_of_nbd}{Integer. Number of neighbors for each spatial unit.}

\item{node.set}{Matrix. Node connections used in spatial modeling.}

\item{ind_zeros_counts}{Logical vector. Indicator for zero entries in \code{A}.}

\item{threshold}{Numeric vector. Threshold values for the size data.}

\item{thr.acces.ind}{Logical vector. Indicator for threshold exceedance.}

\item{thr.prob}{Numeric. Probability for threshold exceedance.}

\item{q.probs}{Numeric vector. Quantiles at which to estimate risk probabilities.}

\item{hyper.mu_adapt_seq2}{Numeric vector. Adaptation sequence for \code{mu} parameters.}

\item{mu_adapt_seq2}{Numeric vector. Adaptation sequence for \code{mu}.}

\item{eta_adapt_seq2}{Numeric vector. Adaptation sequence for \code{eta}.}

\item{samples.store}{Integer. Number of samples to store for posterior summaries.}

\item{init.seed}{Integer. Seed for reproducibility of the random number generation.}
}
\value{
A list containing the following elements:
\item{samples}{Matrix. MCMC samples for the model parameters.}
\item{OOS_with_CIs}{List. Posterior estimates and confidence intervals for out-of-sample diagnostics.}
\item{WS_with_CIs}{List. Posterior estimates and confidence intervals for within-sample diagnostics.}
\item{OOS_qqplots}{List. Data for QQ-plots of the out-of-sample validation.}
\item{WS_qqplots}{List. Data for QQ-plots of the within-sample validation.}
\item{imputed.Y.WSD}{Numeric vector. Imputed values of \code{Y} in within-sample (WS) diagnostics.}
\item{imputed.A.WSD}{Numeric vector. Imputed values of \code{A} in within-sample (WS) diagnostics.}
\item{imputed.Y.OSD}{Numeric vector. Imputed values of \code{Y} in out-of-sample (OOS) diagnostics.}
\item{imputed.A.OSD}{Numeric vector. Imputed values of \code{A} in out-of-sample (OOS) diagnostics.}
\item{post.sum.mean.mu}{Numeric vector. Posterior sum of \code{mu} parameter means.}
\item{post.sum.squre.mu}{Numeric vector. Posterior sum of squared \code{mu} parameters.}
\item{post.sum.mean.eta}{Numeric vector. Posterior sum of \code{eta} parameter means.}
\item{post.sum.squre.eta}{Numeric vector. Posterior sum of squared \code{eta} parameters.}
\item{post.mean.condprob}{Matrix. Posterior mean of conditional probabilities for \code{Y} and \code{A}.}
\item{post.mean.uncondprob}{Matrix. Posterior mean of unconditional probabilities for \code{Y} and \code{A}.}
\item{post.squre.condprob}{Matrix. Posterior sum of squared conditional probabilities for \code{Y} and \code{A}.}
\item{post.squre.uncondprob}{Matrix. Posterior sum of squared unconditional probabilities for \code{Y} and \code{A}.}
\item{post.sum.mean.w1}{Numeric vector. Posterior sum of \code{W1} parameter means.}
\item{post.sum.squre.w1}{Numeric vector. Posterior sum of squared \code{W1} parameters.}
\item{post.sum.mean.w2}{Numeric vector. Posterior sum of \code{W2} parameter means.}
\item{post.sum.squre.w2}{Numeric vector. Posterior sum of squared \code{W2} parameters.}
\item{tuning_param_x_hyper}{Matrix. Adaptive tuning parameters for MCMC iterations.}
\item{Acc.rate eta}{Numeric. Acceptance rate for \code{eta} updates.}
}
\description{
This function implements a Markov Chain Monte Carlo (MCMC) sampler for a joint spatial model
designed to analyze count and size data. It performs Gibbs and Metropolis-Hastings sampling steps
for parameter estimation and can handle both within-sample (WS) and out-of-sample (OOS) cross-validation.
}
\examples{
# Example of how to run the MCMC sampler
result <- mcmc_sampler_joint_model_jSp(N.MCMC = 1000, Y = count_data, ind_NA_Y = is.na(count_data),
                                      A = size_data, ind_NA_A = is.na(size_data), Z1 = covariate_matrix1,
                                      Z2 = covariate_matrix2, model_type = "joint_spatial",
                                      Sim_data = TRUE, thin = 10, adapt = 50, burn_in1 = 100,
                                      burn_in2 = 200, tun.eta = 0.1, tun.mu = 0.1,
                                      tun.hyper.mu = 0.05, tun.hyper.GP = 0.05,
                                      mark_dist = "eGPD", hyper_fixed = list(),
                                      print.result = TRUE, traceplot = FALSE, model.base = FALSE,
                                      CV = "OOS", true.values = NULL, simulation = TRUE,
                                      nbd_info = adjacency_matrix, no_of_nbd = 4,
                                      node.set = node_connections, ind_zeros_counts = zero_indicator,
                                      threshold = threshold_values, thr.acces.ind = threshold_indicator,
                                      thr.prob = 0.1, q.probs = seq(0.1, 0.9, by = 0.1),
                                      hyper.mu_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      mu_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      eta_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      samples.store = 100, init.seed = 123)
}
