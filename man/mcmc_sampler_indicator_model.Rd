% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler_thresholds-indicator-model.R
\name{mcmc_sampler_indicator_model}
\alias{mcmc_sampler_indicator_model}
\title{MCMC Sampler for Threshold Indicator Model}
\usage{
mcmc_sampler_indicator_model(
  N.MCMC,
  A,
  ind.NA,
  CV,
  Z2,
  thin,
  adapt,
  burn_in1,
  burn_in2,
  ind_zero,
  hyper_fixed,
  print.result = TRUE,
  traceplot = FALSE,
  true.values = NULL,
  simulation,
  nbd_info,
  no_of_nbd,
  node.set,
  hyper.mu_adapt_seq2,
  mu_adapt_seq2,
  eta_adapt_seq2,
  init.seed
)
}
\arguments{
\item{N.MCMC}{Integer. Number of MCMC iterations.}

\item{A}{Numeric vector. Size data of length \code{n2}.}

\item{ind.NA}{Logical vector. Indicator for missing values in \code{A}.}

\item{CV}{Character. Cross-validation type: \code{"WS"} for within-sample or \code{"OOS"} for out-of-sample.}

\item{Z2}{Matrix. Covariates for the size data (dimensions \verb{n2 x q}).}

\item{thin}{Integer. Thinning interval for MCMC sampling.}

\item{adapt}{Integer. Adaptation interval for tuning parameter updates.}

\item{burn_in1}{Integer. First burn-in period for MCMC sampling.}

\item{burn_in2}{Integer. Second burn-in period for MCMC sampling.}

\item{ind_zero}{Logical vector. Indicator for zero entries in \code{A}.}

\item{hyper_fixed}{List. Fixed hyperparameters for the model.}

\item{print.result}{Logical. If \code{TRUE}, prints progress during MCMC.}

\item{traceplot}{Logical. If \code{TRUE}, generates traceplots for parameter diagnostics.}

\item{true.values}{Numeric vector. True parameter values for validating simulation experiments.}

\item{simulation}{Logical. If \code{TRUE}, runs the function as a simulation experiment.}

\item{nbd_info}{Matrix. Information on the adjacency structure of spatial units.}

\item{no_of_nbd}{Integer. Number of neighbors for each spatial unit.}

\item{node.set}{Matrix. Node connections used in spatial modeling.}

\item{hyper.mu_adapt_seq2}{Numeric vector. Adaptation sequence for \code{mu} parameters.}

\item{mu_adapt_seq2}{Numeric vector. Adaptation sequence for \code{mu}.}

\item{eta_adapt_seq2}{Numeric vector. Adaptation sequence for \code{eta}.}

\item{init.seed}{Integer. Seed for reproducibility of the random number generation.}
}
\value{
A list containing the following elements:
\item{samples}{Matrix. MCMC samples for the model parameters, including hyperparameters and latent variables.}
\item{imputed.A.WSD}{Numeric vector. Imputed values of \code{A} in within-sample diagnostics.}
\item{imputed.A.squre}{Numeric vector. Sum of squared imputed values of \code{A}.}
\item{post.sum.mean.mu}{Numeric vector. Posterior sum of \code{mu} parameter means.}
\item{post.sum.squre.mu}{Numeric vector. Posterior sum of squared \code{mu} parameters.}
\item{post.sum.mean.w2}{Numeric vector. Posterior sum of \code{w2} parameter means.}
\item{post.sum.squre.w2}{Numeric vector. Posterior sum of squared \code{w2} parameters.}
}
\description{
This function implements a Markov Chain Monte Carlo (MCMC) sampler for a threshold indicator model.
It handles Gibbs sampling and Metropolis-Hastings steps for parameter estimation, focusing on
modeling binary indicators derived from size data.
}
\examples{
# Example of how to run the MCMC sampler
result <- mcmc_sampler_indicator_model(N.MCMC = 1000, A = size_data, ind.NA = is.na(size_data),
                                      CV = "WS", Z2 = covariate_matrix,
                                      thin = 10, adapt = 50, burn_in1 = 100,
                                      burn_in2 = 200, ind_zero = zero_indicator,
                                      hyper_fixed = list(), print.result = TRUE,
                                      traceplot = FALSE, true.values = NULL,
                                      simulation = TRUE, nbd_info = adjacency_matrix,
                                      no_of_nbd = 4, node.set = node_connections,
                                      hyper.mu_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      mu_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      eta_adapt_seq2 = seq(0.05, 0.5, length.out = 100),
                                      init.seed = 123)
}
